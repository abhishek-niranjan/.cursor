---
description: Go backend development standards for scalable, maintainable APIs
globs:
  - "**/*.go"
  - "cmd/**/*"
  - "internal/**/*"
  - "pkg/**/*"
  - "api/**/*"
alwaysApply: false
---

# Backend Development Principles: Go

You are an expert in Go backend development, building scalable RESTful and gRPC APIs using Go 1.22+ standard library and modern Go idioms.

## Core Philosophy

### Development Workflow
- Follow user requirements carefully and precisely
- Think step-by-step: describe your plan for API structure, endpoints, and data flow in pseudocode first
- Confirm the plan before writing code
- Write correct, up-to-date, bug-free, fully functional, secure, and efficient Go code
- Prioritize readability, simplicity, and maintainability
- Leverage Go's simplicity - avoid overengineering

### Code Style
- Write idiomatic Go code following effective Go guidelines
- Use `gofmt`, `goimports`, and `golangci-lint` for code formatting and linting
- Keep functions short and focused (single responsibility)
- Use descriptive names; favor clarity over brevity
- Comment exported functions, types, and packages with doc comments
- Avoid premature optimization; profile before optimizing

## Project Architecture

### Clean Architecture Structure
```
project-root/
├── cmd/
│   ├── api/           # API server entry point
│   │   └── main.go
│   └── worker/        # Background workers
│       └── main.go
├── internal/
│   ├── domain/        # Business entities and logic
│   │   ├── user.go
│   │   └── errors.go
│   ├── handler/       # HTTP/gRPC handlers (transport layer)
│   │   ├── user_handler.go
│   │   └── middleware.go
│   ├── service/       # Business logic layer
│   │   └── user_service.go
│   ├── repository/    # Data access layer
│   │   ├── user_repository.go
│   │   └── postgres.go
│   └── config/        # Configuration management
│       └── config.go
├── pkg/
│   ├── logger/        # Shared logging utilities
│   ├── validator/     # Input validation
│   └── httputil/      # HTTP utilities
├── api/
│   ├── proto/         # Protocol Buffers (gRPC)
│   └── openapi/       # OpenAPI/Swagger specs
├── migrations/        # Database migrations
├── test/             # Integration tests
├── scripts/          # Build and deployment scripts
├── .env.example
├── go.mod
├── go.sum
└── README.md
```

### Dependency Injection
```go
// internal/service/user_service.go
type UserService struct {
    repo   UserRepository
    logger *slog.Logger
    cache  Cache
}

// Constructor function for dependency injection
func NewUserService(repo UserRepository, logger *slog.Logger, cache Cache) *UserService {
    return &UserService{
        repo:   repo,
        logger: logger,
        cache:  cache,
    }
}

// Internal/handler/user_handler.go
type UserHandler struct {
    service UserService
}

func NewUserHandler(service UserService) *UserHandler {
    return &UserHandler{service: service}
}

// cmd/api/main.go - Wire dependencies
func main() {
    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
    db := setupDatabase()
    cache := setupCache()
    
    userRepo := repository.NewUserRepository(db)
    userService := service.NewUserService(userRepo, logger, cache)
    userHandler := handler.NewUserHandler(userService)
    
    // Setup routes and start server
}
```

### Interface-Driven Development
```go
// Define interfaces at point of use (consumer defines interface)
type UserRepository interface {
    GetByID(ctx context.Context, id string) (*domain.User, error)
    Create(ctx context.Context, user *domain.User) error
    Update(ctx context.Context, user *domain.User) error
    Delete(ctx context.Context, id string) error
    List(ctx context.Context, limit, offset int) ([]*domain.User, error)
}

// Concrete implementation
type postgresUserRepository struct {
    db *sql.DB
}

func NewUserRepository(db *sql.DB) UserRepository {
    return &postgresUserRepository{db: db}
}

func (r *postgresUserRepository) GetByID(ctx context.Context, id string) (*domain.User, error) {
    // Implementation
}
```

## Go Best Practices

### Error Handling
```go
// ✅ Always check errors explicitly
result, err := riskyOperation()
if err != nil {
    return fmt.Errorf("failed to perform operation: %w", err)
}

// ✅ Wrap errors with context
user, err := repo.GetByID(ctx, userID)
if err != nil {
    return nil, fmt.Errorf("failed to fetch user %s: %w", userID, err)
}

// ✅ Create custom domain errors
package domain

import "errors"

var (
    ErrUserNotFound     = errors.New("user not found")
    ErrInvalidInput     = errors.New("invalid input")
    ErrUnauthorized     = errors.New("unauthorized")
    ErrDuplicateEmail   = errors.New("email already exists")
)

// ✅ Check error types
if errors.Is(err, domain.ErrUserNotFound) {
    return http.StatusNotFound, "User not found"
}

// ✅ Sentinel errors for control flow
func (s *UserService) GetUser(ctx context.Context, id string) (*domain.User, error) {
    user, err := s.repo.GetByID(ctx, id)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, domain.ErrUserNotFound
        }
        return nil, fmt.Errorf("repository error: %w", err)
    }
    return user, nil
}

// ❌ Don't panic in library code (only in main/init for unrecoverable errors)
// ❌ Don't ignore errors
```

### Context Propagation
```go
// ✅ Always accept context as first parameter
func (s *UserService) CreateUser(ctx context.Context, req *CreateUserRequest) (*domain.User, error) {
    // Check for cancellation
    select {
    case <-ctx.Done():
        return nil, ctx.Err()
    default:
    }
    
    // Pass context to repository
    user, err := s.repo.Create(ctx, userFromRequest(req))
    if err != nil {
        return nil, err
    }
    
    return user, nil
}

// ✅ Use context for deadlines and cancellation
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

result, err := service.LongRunningOperation(ctx)

// ✅ Use context for request-scoped values
type contextKey string

const userIDKey contextKey = "userID"

func WithUserID(ctx context.Context, userID string) context.Context {
    return context.WithValue(ctx, userIDKey, userID)
}

func GetUserID(ctx context.Context) (string, bool) {
    userID, ok := ctx.Value(userIDKey).(string)
    return userID, ok
}
```

### Struct Patterns
```go
// ✅ Use struct embedding for composition
type BaseRepository struct {
    db *sql.DB
}

type UserRepository struct {
    BaseRepository
    cache Cache
}

// ✅ Use functional options for complex constructors
type ServerOptions struct {
    Port    int
    Timeout time.Duration
    Logger  *slog.Logger
}

type ServerOption func(*ServerOptions)

func WithPort(port int) ServerOption {
    return func(opts *ServerOptions) {
        opts.Port = port
    }
}

func WithTimeout(timeout time.Duration) ServerOption {
    return func(opts *ServerOptions) {
        opts.Timeout = timeout
    }
}

func NewServer(opts ...ServerOption) *Server {
    options := &ServerOptions{
        Port:    8080,
        Timeout: 30 * time.Second,
    }
    
    for _, opt := range opts {
        opt(options)
    }
    
    return &Server{options: options}
}

// Usage
server := NewServer(
    WithPort(9000),
    WithTimeout(60 * time.Second),
)
```

## HTTP API Development (Go 1.22+ ServeMux)

### Route Handler Pattern
```go
package handler

import (
    "encoding/json"
    "log/slog"
    "net/http"
)

type UserHandler struct {
    service UserService
    logger  *slog.Logger
}

func NewUserHandler(service UserService, logger *slog.Logger) *UserHandler {
    return &UserHandler{
        service: service,
        logger:  logger,
    }
}

// RegisterRoutes registers all user routes
func (h *UserHandler) RegisterRoutes(mux *http.ServeMux) {
    mux.HandleFunc("GET /api/users", h.ListUsers)
    mux.HandleFunc("GET /api/users/{id}", h.GetUser)
    mux.HandleFunc("POST /api/users", h.CreateUser)
    mux.HandleFunc("PUT /api/users/{id}", h.UpdateUser)
    mux.HandleFunc("DELETE /api/users/{id}", h.DeleteUser)
}

// GetUser handles GET /api/users/{id}
func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    id := r.PathValue("id")
    
    if id == "" {
        h.respondError(w, http.StatusBadRequest, "user ID is required")
        return
    }
    
    user, err := h.service.GetUser(ctx, id)
    if err != nil {
        if errors.Is(err, domain.ErrUserNotFound) {
            h.respondError(w, http.StatusNotFound, "user not found")
            return
        }
        h.logger.Error("failed to get user", "error", err, "id", id)
        h.respondError(w, http.StatusInternalServerError, "internal server error")
        return
    }
    
    h.respondJSON(w, http.StatusOK, user)
}

// CreateUser handles POST /api/users
func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    var req CreateUserRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        h.respondError(w, http.StatusBadRequest, "invalid request body")
        return
    }
    defer r.Body.Close()
    
    // Validate request
    if err := req.Validate(); err != nil {
        h.respondError(w, http.StatusBadRequest, err.Error())
        return
    }
    
    user, err := h.service.CreateUser(ctx, &req)
    if err != nil {
        if errors.Is(err, domain.ErrDuplicateEmail) {
            h.respondError(w, http.StatusConflict, "email already exists")
            return
        }
        h.logger.Error("failed to create user", "error", err)
        h.respondError(w, http.StatusInternalServerError, "internal server error")
        return
    }
    
    h.respondJSON(w, http.StatusCreated, user)
}

// Helper methods
func (h *UserHandler) respondJSON(w http.ResponseWriter, status int, data interface{}) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteStatus(status)
    json.NewEncoder(w).Encode(data)
}

func (h *UserHandler) respondError(w http.ResponseWriter, status int, message string) {
    h.respondJSON(w, status, map[string]string{"error": message})
}
```

### Middleware Pattern
```go
package middleware

import (
    "log/slog"
    "net/http"
    "time"
)

// Logging middleware
func Logging(logger *slog.Logger) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()
            
            // Wrap response writer to capture status code
            wrapped := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
            
            next.ServeHTTP(wrapped, r)
            
            logger.Info("request completed",
                "method", r.Method,
                "path", r.URL.Path,
                "status", wrapped.statusCode,
                "duration", time.Since(start),
                "remote_addr", r.RemoteAddr,
            )
        })
    }
}

type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}

// Recovery middleware
func Recovery(logger *slog.Logger) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            defer func() {
                if err := recover(); err != nil {
                    logger.Error("panic recovered",
                        "error", err,
                        "path", r.URL.Path,
                    )
                    http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                }
            }()
            next.ServeHTTP(w, r)
        })
    }
}

// CORS middleware
func CORS(allowedOrigins []string) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            origin := r.Header.Get("Origin")
            
            // Check if origin is allowed
            allowed := false
            for _, o := range allowedOrigins {
                if o == "*" || o == origin {
                    allowed = true
                    break
                }
            }
            
            if allowed {
                w.Header().Set("Access-Control-Allow-Origin", origin)
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
            }
            
            if r.Method == "OPTIONS" {
                w.WriteHeader(http.StatusNoContent)
                return
            }
            
            next.ServeHTTP(w, r)
        })
    }
}

// Chain multiple middleware
func Chain(h http.Handler, middlewares ...func(http.Handler) http.Handler) http.Handler {
    for i := len(middlewares) - 1; i >= 0; i-- {
        h = middlewares[i](h)
    }
    return h
}

// Usage in main.go
func main() {
    mux := http.NewServeMux()
    
    // Register routes
    userHandler.RegisterRoutes(mux)
    
    // Apply middleware chain
    handler := Chain(mux,
        middleware.Recovery(logger),
        middleware.Logging(logger),
        middleware.CORS([]string{"*"}),
    )
    
    http.ListenAndServe(":8080", handler)
}
```

### Request/Response Patterns
```go
// Request DTOs with validation
type CreateUserRequest struct {
    Name     string `json:"name"`
    Email    string `json:"email"`
    Password string `json:"password"`
}

func (r *CreateUserRequest) Validate() error {
    if r.Name == "" {
        return errors.New("name is required")
    }
    if r.Email == "" {
        return errors.New("email is required")
    }
    if !isValidEmail(r.Email) {
        return errors.New("invalid email format")
    }
    if len(r.Password) < 8 {
        return errors.New("password must be at least 8 characters")
    }
    return nil
}

// Response DTOs
type UserResponse struct {
    ID        string    `json:"id"`
    Name      string    `json:"name"`
    Email     string    `json:"email"`
    CreatedAt time.Time `json:"created_at"`
}

func ToUserResponse(user *domain.User) *UserResponse {
    return &UserResponse{
        ID:        user.ID,
        Name:      user.Name,
        Email:     user.Email,
        CreatedAt: user.CreatedAt,
    }
}

// Paginated responses
type PaginatedResponse struct {
    Data       interface{} `json:"data"`
    Page       int         `json:"page"`
    PerPage    int         `json:"per_page"`
    Total      int         `json:"total"`
    TotalPages int         `json:"total_pages"`
}

// Error responses
type ErrorResponse struct {
    Error   string `json:"error"`
    Code    string `json:"code,omitempty"`
    Details any    `json:"details,omitempty"`
}
```

## Database Interaction

### Database Setup with Connection Pooling
```go
package repository

import (
    "database/sql"
    "time"
    
    _ "github.com/lib/pq"
)

func NewPostgresDB(dsn string) (*sql.DB, error) {
    db, err := sql.Open("postgres", dsn)
    if err != nil {
        return nil, fmt.Errorf("failed to open database: %w", err)
    }
    
    // Configure connection pool
    db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(5)
    db.SetConnMaxLifetime(5 * time.Minute)
    db.SetConnMaxIdleTime(10 * time.Minute)
    
    // Verify connection
    if err := db.Ping(); err != nil {
        return nil, fmt.Errorf("failed to ping database: %w", err)
    }
    
    return db, nil
}
```

### Repository Pattern with Prepared Statements
```go
type postgresUserRepository struct {
    db *sql.DB
}

func NewUserRepository(db *sql.DB) UserRepository {
    return &postgresUserRepository{db: db}
}

func (r *postgresUserRepository) GetByID(ctx context.Context, id string) (*domain.User, error) {
    query := `
        SELECT id, name, email, created_at, updated_at
        FROM users
        WHERE id = $1 AND deleted_at IS NULL
    `
    
    var user domain.User
    err := r.db.QueryRowContext(ctx, query, id).Scan(
        &user.ID,
        &user.Name,
        &user.Email,
        &user.CreatedAt,
        &user.UpdatedAt,
    )
    
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, domain.ErrUserNotFound
        }
        return nil, fmt.Errorf("failed to query user: %w", err)
    }
    
    return &user, nil
}

func (r *postgresUserRepository) Create(ctx context.Context, user *domain.User) error {
    query := `
        INSERT INTO users (id, name, email, password_hash, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6)
    `
    
    _, err := r.db.ExecContext(ctx, query,
        user.ID,
        user.Name,
        user.Email,
        user.PasswordHash,
        time.Now(),
        time.Now(),
    )
    
    if err != nil {
        // Check for duplicate key violation
        if isDuplicateKeyError(err) {
            return domain.ErrDuplicateEmail
        }
        return fmt.Errorf("failed to create user: %w", err)
    }
    
    return nil
}

func (r *postgresUserRepository) List(ctx context.Context, limit, offset int) ([]*domain.User, error) {
    query := `
        SELECT id, name, email, created_at, updated_at
        FROM users
        WHERE deleted_at IS NULL
        ORDER BY created_at DESC
        LIMIT $1 OFFSET $2
    `
    
    rows, err := r.db.QueryContext(ctx, query, limit, offset)
    if err != nil {
        return nil, fmt.Errorf("failed to query users: %w", err)
    }
    defer rows.Close()
    
    var users []*domain.User
    for rows.Next() {
        var user domain.User
        if err := rows.Scan(&user.ID, &user.Name, &user.Email, &user.CreatedAt, &user.UpdatedAt); err != nil {
            return nil, fmt.Errorf("failed to scan user: %w", err)
        }
        users = append(users, &user)
    }
    
    if err := rows.Err(); err != nil {
        return nil, fmt.Errorf("rows iteration error: %w", err)
    }
    
    return users, nil
}
```

### Transaction Management
```go
func (r *postgresUserRepository) CreateUserWithProfile(ctx context.Context, user *domain.User, profile *domain.Profile) error {
    tx, err := r.db.BeginTx(ctx, nil)
    if err != nil {
        return fmt.Errorf("failed to begin transaction: %w", err)
    }
    defer tx.Rollback() // Rollback if not committed
    
    // Insert user
    userQuery := `INSERT INTO users (id, name, email) VALUES ($1, $2, $3)`
    if _, err := tx.ExecContext(ctx, userQuery, user.ID, user.Name, user.Email); err != nil {
        return fmt.Errorf("failed to insert user: %w", err)
    }
    
    // Insert profile
    profileQuery := `INSERT INTO profiles (user_id, bio, avatar_url) VALUES ($1, $2, $3)`
    if _, err := tx.ExecContext(ctx, profileQuery, user.ID, profile.Bio, profile.AvatarURL); err != nil {
        return fmt.Errorf("failed to insert profile: %w", err)
    }
    
    // Commit transaction
    if err := tx.Commit(); err != nil {
        return fmt.Errorf("failed to commit transaction: %w", err)
    }
    
    return nil
}
```

## Concurrency Patterns

### Worker Pool Pattern
```go
func ProcessItems(ctx context.Context, items []Item) error {
    const numWorkers = 5
    
    jobs := make(chan Item, len(items))
    results := make(chan error, len(items))
    
    // Start workers
    var wg sync.WaitGroup
    for i := 0; i < numWorkers; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for item := range jobs {
                if err := processItem(ctx, item); err != nil {
                    results <- err
                    continue
                }
                results <- nil
            }
        }()
    }
    
    // Send jobs
    for _, item := range items {
        jobs <- item
    }
    close(jobs)
    
    // Wait for workers to finish
    wg.Wait()
    close(results)
    
    // Collect errors
    var errs []error
    for err := range results {
        if err != nil {
            errs = append(errs, err)
        }
    }
    
    if len(errs) > 0 {
        return fmt.Errorf("failed to process %d items", len(errs))
    }
    
    return nil
}
```

### Rate Limiting with Semaphore
```go
import "golang.org/x/sync/semaphore"

func ProcessWithLimit(ctx context.Context, items []Item, maxConcurrent int64) error {
    sem := semaphore.NewWeighted(maxConcurrent)
    
    var wg sync.WaitGroup
    errChan := make(chan error, len(items))
    
    for _, item := range items {
        if err := sem.Acquire(ctx, 1); err != nil {
            return fmt.Errorf("failed to acquire semaphore: %w", err)
        }
        
        wg.Add(1)
        go func(item Item) {
            defer sem.Release(1)
            defer wg.Done()
            
            if err := processItem(ctx, item); err != nil {
                errChan <- err
            }
        }(item)
    }
    
    wg.Wait()
    close(errChan)
    
    // Check for errors
    for err := range errChan {
        if err != nil {
            return err
        }
    }
    
    return nil
}
```

### Safe Goroutine Patterns
```go
// ✅ Capture loop variable correctly
for _, item := range items {
    item := item // Create new variable for goroutine
    go func() {
        process(item)
    }()
}

// ✅ Or pass as parameter
for _, item := range items {
    go func(item Item) {
        process(item)
    }(item)
}

// ✅ Always ensure goroutines can exit
func StartWorker(ctx context.Context) {
    ticker := time.NewTicker(time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return // Exit when context is cancelled
        case <-ticker.C:
            doWork()
        }
    }
}
```

## Testing Best Practices

### Table-Driven Tests
```go
func TestCalculateTotal(t *testing.T) {
    tests := []struct {
        name      string
        price     float64
        quantity  int
        discount  float64
        want      float64
        wantErr   bool
    }{
        {
            name:     "normal calculation",
            price:    100.0,
            quantity: 2,
            discount: 10.0,
            want:     180.0,
            wantErr:  false,
        },
        {
            name:     "zero discount",
            price:    50.0,
            quantity: 3,
            discount: 0.0,
            want:     150.0,
            wantErr:  false,
        },
        {
            name:     "negative price",
            price:    -100.0,
            quantity: 1,
            discount: 0.0,
            want:     0.0,
            wantErr:  true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := CalculateTotal(tt.price, tt.quantity, tt.discount)
            
            if (err != nil) != tt.wantErr {
                t.Errorf("CalculateTotal() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            
            if got != tt.want {
                t.Errorf("CalculateTotal() = %v, want %v", got, tt.want)
            }
        })
    }
}
```

### Mocking Interfaces
```go
// Mock repository for testing
type mockUserRepository struct {
    users map[string]*domain.User
    err   error
}

func (m *mockUserRepository) GetByID(ctx context.Context, id string) (*domain.User, error) {
    if m.err != nil {
        return nil, m.err
    }
    
    user, ok := m.users[id]
    if !ok {
        return nil, domain.ErrUserNotFound
    }
    
    return user, nil
}

func (m *mockUserRepository) Create(ctx context.Context, user *domain.User) error {
    if m.err != nil {
        return m.err
    }
    
    m.users[user.ID] = user
    return nil
}

// Test using mock
func TestUserService_GetUser(t *testing.T) {
    mockRepo := &mockUserRepository{
        users: map[string]*domain.User{
            "123": {ID: "123", Name: "John", Email: "john@example.com"},
        },
    }
    
    logger := slog.New(slog.NewTextHandler(io.Discard, nil))
    service := NewUserService(mockRepo, logger, nil)
    
    user, err := service.GetUser(context.Background(), "123")
    
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
    
    if user.Name != "John" {
        t.Errorf("expected name 'John', got '%s'", user.Name)
    }
}
```

### Integration Tests
```go
// +build integration

package repository_test

import (
    "context"
    "testing"
    "time"
)

func TestUserRepository_Integration(t *testing.T) {
    // Setup test database
    db := setupTestDB(t)
    defer db.Close()
    
    repo := repository.NewUserRepository(db)
    ctx := context.Background()
    
    // Test Create
    user := &domain.User{
        ID:    "test-123",
        Name:  "Test User",
        Email: "test@example.com",
    }
    
    err := repo.Create(ctx, user)
    if err != nil {
        t.Fatalf("failed to create user: %v", err)
    }
    
    // Test GetByID
    retrieved, err := repo.GetByID(ctx, user.ID)
    if err != nil {
        t.Fatalf("failed to get user: %v", err)
    }
    
    if retrieved.Email != user.Email {
        t.Errorf("expected email %s, got %s", user.Email, retrieved.Email)
    }
    
    // Cleanup
    teardownTestData(t, db)
}

func setupTestDB(t *testing.T) *sql.DB {
    dsn := os.Getenv("TEST_DATABASE_URL")
    if dsn == "" {
        t.Skip("TEST_DATABASE_URL not set")
    }
    
    db, err := sql.Open("postgres", dsn)
    if err != nil {
        t.Fatalf("failed to connect to test database: %v", err)
    }
    
    // Run migrations
    runMigrations(t, db)
    
    return db
}
```

## Configuration Management

### Environment-Based Configuration
```go
package config

import (
    "fmt"
    "os"
    "strconv"
    "time"
)

type Config struct {
    Server   ServerConfig
    Database DatabaseConfig
    Redis    RedisConfig
    JWT      JWTConfig
}

type ServerConfig struct {
    Port         int
    ReadTimeout  time.Duration
    WriteTimeout time.Duration
}

type DatabaseConfig struct {
    DSN             string
    MaxOpenConns    int
    MaxIdleConns    int
    ConnMaxLifetime time.Duration
}

type RedisConfig struct {
    Addr     string
    Password string
    DB       int
}

type JWTConfig struct {
    Secret     string
    Expiration time.Duration
}

func Load() (*Config, error) {
    cfg := &Config{
        Server: ServerConfig{
            Port:         getEnvAsInt("SERVER_PORT", 8080),
            ReadTimeout:  getEnvAsDuration("SERVER_READ_TIMEOUT", 10*time.Second),
            WriteTimeout: getEnvAsDuration("SERVER_WRITE_TIMEOUT", 10*time.Second),
        },
        Database: DatabaseConfig{
            DSN:             getEnv("DATABASE_URL", ""),
            MaxOpenConns:    getEnvAsInt("DB_MAX_OPEN_CONNS", 25),
            MaxIdleConns:    getEnvAsInt("DB_MAX_IDLE_CONNS", 5),
            ConnMaxLifetime: getEnvAsDuration("DB_CONN_MAX_LIFETIME", 5*time.Minute),
        },
        Redis: RedisConfig{
            Addr:     getEnv("REDIS_ADDR", "localhost:6379"),
            Password: getEnv("REDIS_PASSWORD", ""),
            DB:       getEnvAsInt("REDIS_DB", 0),
        },
        JWT: JWTConfig{
            Secret:     getEnv("JWT_SECRET", ""),
            Expiration: getEnvAsDuration("JWT_EXPIRATION", 24*time.Hour),
        },
    }
    
    if err := cfg.Validate(); err != nil {
        return nil, err
    }
    
    return cfg, nil
}

func (c *Config) Validate() error {
    if c.Database.DSN == "" {
        return fmt.Errorf("DATABASE_URL is required")
    }
    if c.JWT.Secret == "" {
        return fmt.Errorf("JWT_SECRET is required")
    }
    return nil
}

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func getEnvAsInt(key string, defaultValue int) int {
    if value := os.Getenv(key); value != "" {
        if intValue, err := strconv.Atoi(value); err == nil {
            return intValue
        }
    }
    return defaultValue
}

func getEnvAsDuration(key string, defaultValue time.Duration) time.Duration {
    if value := os.Getenv(key); value != "" {
        if duration, err := time.ParseDuration(value); err == nil {
            return duration
        }
    }
    return defaultValue
}
```

## Security Best Practices

### Input Validation
```go
import "github.com/go-playground/validator/v10"

type CreateUserRequest struct {
    Name     string `json:"name" validate:"required,min=2,max=100"`
    Email    string `json:"email" validate:"required,email"`
    Password string `json:"password" validate:"required,min=8,max=72"`
    Age      int    `json:"age" validate:"required,gte=18,lte=120"`
}

var validate = validator.New()

func (r *CreateUserRequest) Validate() error {
    return validate.Struct(r)
}
```

### Password Hashing
```go
import "golang.org/x/crypto/bcrypt"

func HashPassword(password string) (string, error) {
    hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return "", fmt.Errorf("failed to hash password: %w", err)
    }
    return string(hash), nil
}

func VerifyPassword(hashedPassword, password string) error {
    return bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
}
```

### JWT Authentication
```go
import "github.com/golang-jwt/jwt/v5"

type Claims struct {
    UserID string `json:"user_id"`
    Email  string `json:"email"`
    jwt.RegisteredClaims
}

func GenerateToken(userID, email, secret string, expiration time.Duration) (string, error) {
    claims := Claims{
        UserID: userID,
        Email:  email,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(expiration)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte(secret))
}

func ValidateToken(tokenString, secret string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        return []byte(secret), nil
    })
    
    if err != nil {
        return nil, err
    }
    
    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }
    
    return nil, fmt.Errorf("invalid token")
}
```

## Logging and Observability

### Structured Logging
```go
import "log/slog"

func setupLogger() *slog.Logger {
    opts := &slog.HandlerOptions{
        Level: slog.LevelInfo,
    }
    
    handler := slog.NewJSONHandler(os.Stdout, opts)
    return slog.New(handler)
}

// Usage
logger.Info("user created",
    "user_id", userID,
    "email", email,
    "ip_address", r.RemoteAddr,
)

logger.Error("failed to process request",
    "error", err,
    "request_id", requestID,
    "path", r.URL.Path,
)
```

## Code Review Checklist

- [ ] Error handling is explicit and errors are wrapped with context
- [ ] Context is propagated through all function calls
- [ ] No goroutine leaks (all goroutines can exit)
- [ ] Database connections are properly closed/returned to pool
- [ ] SQL injection prevented with prepared statements
- [ ] Input validation on all user inputs
- [ ] Passwords are hashed with bcrypt
- [ ] Secrets are loaded from environment variables
- [ ] Logging uses structured logging (slog)
- [ ] HTTP handlers follow standard patterns
- [ ] Middleware is properly chained
- [ ] Tests are table-driven with good coverage
- [ ] Interfaces defined at point of use
- [ ] No use of panic except in main/init
- [ ] Code formatted with gofmt/goimports
- [ ] Passes golangci-lint checks
- [ ] Dependencies are minimal and well-maintained
- [ ] Configuration is environment-based
- [ ] Transactions are properly committed/rolled back
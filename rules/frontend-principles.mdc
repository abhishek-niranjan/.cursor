---
description: React, Next.js, and modern frontend development best practices with TypeScript
globs:
  - "**/*.tsx"
  - "**/*.ts"
  - "**/*.jsx"
  - "**/*.js"
  - "app/**/*"
  - "components/**/*"
  - "pages/**/*"
  - "src/**/*"
  - "hooks/**/*"
  - "utils/**/*"
  - "lib/**/*"
alwaysApply: false
---

# Frontend Development Principles: React, Next.js & TypeScript

You are an expert in TypeScript, Node.js, Next.js App Router, React 19, Shadcn UI, Radix UI, Tailwind CSS, and modern frontend development.

## Core Philosophy

### Code Style
- Write concise, technical TypeScript code with accurate examples
- Use functional and declarative programming patterns; avoid classes
- Prefer iteration and modularization over code duplication
- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`, `shouldRender`)
- Follow single responsibility principle for functions and components
- Structure files logically: exported component, subcomponents, helpers, static content, types

### Naming Conventions
- **Directories**: lowercase with dashes (e.g., `components/auth-wizard`)
- **Component Files**: PascalCase (e.g., `UserProfile.tsx`)
- **Utility Files**: camelCase (e.g., `formatDate.ts`, `apiClient.ts`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `API_BASE_URL`)
- **React Components**: PascalCase with descriptive names
- **Hooks**: camelCase starting with `use` (e.g., `useUserData`)
- **Types/Interfaces**: PascalCase (e.g., `User`, `ApiResponse`)
- Favor named exports for components and utilities

## TypeScript Standards

### Type Safety
- Use TypeScript for all code; prefer `interface` over `type` for object shapes
- Avoid `enum`; use const objects with `as const` assertion instead:
  ```typescript
  // ❌ Avoid
  enum Status { Active, Inactive }
  
  // ✅ Prefer
  const Status = {
    ACTIVE: 'active',
    INACTIVE: 'inactive',
  } as const;
  
  type StatusType = typeof Status[keyof typeof Status];
  ```
- Use functional components with TypeScript interfaces for props
- Enable strict mode in `tsconfig.json`
- Avoid `any` type; use precise types or `unknown` when type is uncertain
- Use type inference where possible to reduce verbosity
- Leverage discriminated unions for complex state:
  ```typescript
  type LoadingState = 
    | { status: 'idle' }
    | { status: 'loading' }
    | { status: 'success'; data: User[] }
    | { status: 'error'; error: Error };
  ```

### TypeScript Best Practices
- Define prop interfaces inline for simple components:
  ```typescript
  export function Button({ 
    label, 
    onClick 
  }: { 
    label: string; 
    onClick: () => void;
  }) {
    return <button onClick={onClick}>{label}</button>;
  }
  ```
- Extract complex interfaces to separate type files:
  ```typescript
  // types/user.ts
  export interface User {
    id: string;
    name: string;
    email: string;
  }
  ```
- Use generics for reusable components and utilities:
  ```typescript
  function useLocalStorage<T>(key: string, initialValue: T) {
    // Implementation
  }
  ```
- Use `Partial<T>` for optional updates, `Required<T>` for making all props required
- Use `Pick<T, K>` and `Omit<T, K>` for type transformations
- Use `ReturnType<typeof fn>` to infer return types

## React Best Practices

### Component Structure
```typescript
// ✅ Recommended structure
import { useState, useEffect } from 'react';
import type { FC } from 'react';

// Types
interface UserProfileProps {
  userId: string;
  onUpdate?: (user: User) => void;
}

// Component
export const UserProfile: FC<UserProfileProps> = ({ userId, onUpdate }) => {
  // Hooks
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  
  // Effects
  useEffect(() => {
    fetchUser(userId).then(setUser).finally(() => setIsLoading(false));
  }, [userId]);
  
  // Event handlers
  const handleUpdate = () => {
    if (user) onUpdate?.(user);
  };
  
  // Early returns
  if (isLoading) return <Spinner />;
  if (!user) return <ErrorMessage />;
  
  // Render
  return (
    <div>
      <h1>{user.name}</h1>
      <button onClick={handleUpdate}>Update</button>
    </div>
  );
};

// Subcomponents (if needed)
const Spinner = () => <div>Loading...</div>;
const ErrorMessage = () => <div>User not found</div>;
```

### Hooks Guidelines
- Call hooks at the top level (never inside conditions, loops, or nested functions)
- Custom hooks must start with `use` prefix
- Extract complex logic into custom hooks:
  ```typescript
  function useUserData(userId: string) {
    const [data, setData] = useState<User | null>(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<Error | null>(null);
    
    useEffect(() => {
      fetchUser(userId)
        .then(setData)
        .catch(setError)
        .finally(() => setIsLoading(false));
    }, [userId]);
    
    return { data, isLoading, error };
  }
  ```
- Memoize expensive computations with `useMemo`:
  ```typescript
  const sortedUsers = useMemo(() => {
    return users.sort((a, b) => a.name.localeCompare(b.name));
  }, [users]);
  ```
- Memoize callbacks with `useCallback` when passed to memoized children:
  ```typescript
  const handleClick = useCallback(() => {
    doSomething(data);
  }, [data]);
  ```
- Use `useRef` for DOM references and mutable values that don't trigger re-renders

### Component Patterns

#### Compound Components
```typescript
const Card = ({ children }: { children: React.ReactNode }) => {
  return <div className="card">{children}</div>;
};

Card.Header = ({ children }: { children: React.ReactNode }) => {
  return <div className="card-header">{children}</div>;
};

Card.Body = ({ children }: { children: React.ReactNode }) => {
  return <div className="card-body">{children}</div>;
};

// Usage
<Card>
  <Card.Header>Title</Card.Header>
  <Card.Body>Content</Card.Body>
</Card>
```

#### Render Props
```typescript
<DataProvider>
  {({ data, isLoading }) => (
    isLoading ? <Spinner /> : <Display data={data} />
  )}
</DataProvider>
```

#### Higher Order Components (use sparingly, prefer hooks)
```typescript
function withAuth<P extends object>(
  Component: React.ComponentType<P>
) {
  return (props: P) => {
    const { isAuthenticated } = useAuth();
    if (!isAuthenticated) return <Redirect to="/login" />;
    return <Component {...props} />;
  };
}
```

## Next.js App Router Patterns

### Server vs Client Components

**Default to Server Components** (no 'use client' directive needed):
- Data fetching
- Backend logic
- Database queries
- SEO-critical content
- Static content
- Accessing environment variables

**Use Client Components only when needed** (add 'use client' directive):
- Event handlers (onClick, onChange, onSubmit)
- Browser APIs (localStorage, window, document)
- State management (useState, useReducer, useContext)
- Effects (useEffect, useLayoutEffect)
- Custom hooks using above features
- React class components (legacy)

### Server Component Data Fetching
```typescript
// app/users/page.tsx (Server Component)
async function getUsers() {
  const res = await fetch('https://api.example.com/users', {
    cache: 'force-cache', // Static generation
    // OR
    cache: 'no-store', // Dynamic, fetch every request
    // OR
    next: { revalidate: 3600 } // ISR, revalidate every hour
  });
  
  if (!res.ok) {
    throw new Error('Failed to fetch users');
  }
  
  return res.json();
}

export default async function UsersPage() {
  const users = await getUsers();
  
  return (
    <div>
      <h1>Users</h1>
      <UserList users={users} />
    </div>
  );
}
```

### Client Component Pattern
```typescript
'use client';

import { useState, useEffect } from 'react';

export function UserList({ initialUsers }: { initialUsers: User[] }) {
  const [users, setUsers] = useState(initialUsers);
  const [filter, setFilter] = useState('');
  
  const filteredUsers = users.filter(u => 
    u.name.toLowerCase().includes(filter.toLowerCase())
  );
  
  return (
    <div>
      <input 
        type="text"
        value={filter}
        onChange={(e) => setFilter(e.target.value)}
        placeholder="Filter users..."
      />
      {filteredUsers.map(user => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  );
}
```

### File Structure (App Router)
```
app/
├── layout.tsx          # Root layout
├── page.tsx            # Home page (/)
├── loading.tsx         # Loading UI
├── error.tsx           # Error boundary
├── not-found.tsx       # 404 page
├── global.css          # Global styles
├── (auth)/             # Route group (not in URL)
│   ├── login/
│   │   └── page.tsx
│   └── register/
│       └── page.tsx
├── dashboard/
│   ├── layout.tsx      # Dashboard layout
│   ├── page.tsx        # /dashboard
│   ├── loading.tsx     # Loading state
│   └── settings/
│       └── page.tsx    # /dashboard/settings
└── api/                # API routes
    └── users/
        └── route.ts    # /api/users
```

### Loading States
```typescript
// app/dashboard/loading.tsx
export default function Loading() {
  return <DashboardSkeleton />;
}
```

### Error Handling
```typescript
// app/dashboard/error.tsx
'use client';

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <p>{error.message}</p>
      <button onClick={reset}>Try again</button>
    </div>
  );
}
```

### API Routes (Route Handlers)
```typescript
// app/api/users/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const query = searchParams.get('query');
  
  const users = await fetchUsers(query);
  
  return NextResponse.json({ users });
}

export async function POST(request: NextRequest) {
  const body = await request.json();
  
  // Validate with Zod
  const validatedData = userSchema.parse(body);
  
  const user = await createUser(validatedData);
  
  return NextResponse.json({ user }, { status: 201 });
}
```

### Dynamic Routes
```typescript
// app/users/[id]/page.tsx
interface PageProps {
  params: { id: string };
  searchParams: { [key: string]: string | string[] | undefined };
}

export default async function UserPage({ params }: PageProps) {
  const user = await getUser(params.id);
  
  return <UserProfile user={user} />;
}

// Generate static params for SSG
export async function generateStaticParams() {
  const users = await getAllUsers();
  
  return users.map((user) => ({
    id: user.id,
  }));
}
```

### Server Actions
```typescript
// app/actions.ts
'use server';

import { revalidatePath } from 'next/cache';

export async function createUser(formData: FormData) {
  const name = formData.get('name') as string;
  const email = formData.get('email') as string;
  
  // Validate
  if (!name || !email) {
    return { error: 'Name and email are required' };
  }
  
  // Create user
  await db.user.create({ data: { name, email } });
  
  // Revalidate cache
  revalidatePath('/users');
  
  return { success: true };
}

// Usage in Client Component
'use client';
import { createUser } from './actions';

export function UserForm() {
  return (
    <form action={createUser}>
      <input name="name" />
      <input name="email" type="email" />
      <button type="submit">Create</button>
    </form>
  );
}
```

## Performance Optimization

### Minimize 'use client' Directive
Push 'use client' as far down the component tree as possible:
```typescript
// ❌ Avoid
'use client';

export default function Page() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <Header /> {/* Now unnecessarily client-side */}
      <Counter count={count} setCount={setCount} />
    </div>
  );
}

// ✅ Better
export default function Page() {
  // Server Component
  return (
    <div>
      <Header /> {/* Stays server-side */}
      <CounterClient /> {/* Only this is client */}
    </div>
  );
}

// components/CounterClient.tsx
'use client';
export function CounterClient() {
  const [count, setCount] = useState(0);
  return <Counter count={count} setCount={setCount} />;
}
```

### Code Splitting
```typescript
import dynamic from 'next/dynamic';

// Lazy load component
const HeavyComponent = dynamic(() => import('./HeavyComponent'), {
  loading: () => <Spinner />,
  ssr: false, // Disable SSR if not needed
});

export default function Page() {
  return (
    <div>
      <HeavyComponent />
    </div>
  );
}
```

### Image Optimization
```typescript
import Image from 'next/image';

export function Hero() {
  return (
    <Image
      src="/hero.jpg"
      alt="Hero image"
      width={1200}
      height={600}
      priority // Load immediately for LCP
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,..."
    />
  );
}
```

### React.memo for Pure Components
```typescript
import { memo } from 'react';

interface Props {
  user: User;
  onSelect: (id: string) => void;
}

export const UserCard = memo(function UserCard({ user, onSelect }: Props) {
  return (
    <div onClick={() => onSelect(user.id)}>
      {user.name}
    </div>
  );
});
```

## State Management

### Local State (useState)
```typescript
const [count, setCount] = useState(0);
const [user, setUser] = useState<User | null>(null);
const [items, setItems] = useState<Item[]>([]);

// Update patterns
setCount(count + 1); // Simple update
setCount(c => c + 1); // Functional update (safer)
setItems([...items, newItem]); // Immutable array update
```

### URL State (nuqs library)
```typescript
import { useQueryState } from 'nuqs';

export function SearchPage() {
  const [search, setSearch] = useQueryState('q');
  const [page, setPage] = useQueryState('page', { defaultValue: '1' });
  
  return (
    <input 
      value={search || ''} 
      onChange={(e) => setSearch(e.target.value)}
    />
  );
}
```

### Context API (for theme, auth)
```typescript
// contexts/AuthContext.tsx
'use client';

import { createContext, useContext, useState } from 'react';

interface AuthContextType {
  user: User | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  
  const login = async (email: string, password: string) => {
    const user = await authService.login(email, password);
    setUser(user);
  };
  
  const logout = () => setUser(null);
  
  return (
    <AuthContext.Provider value={{ user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be used within AuthProvider');
  return context;
}
```

### Zustand (lightweight global state)
```typescript
import { create } from 'zustand';

interface CartStore {
  items: CartItem[];
  addItem: (item: CartItem) => void;
  removeItem: (id: string) => void;
  clearCart: () => void;
}

export const useCartStore = create<CartStore>((set) => ({
  items: [],
  addItem: (item) => set((state) => ({ 
    items: [...state.items, item] 
  })),
  removeItem: (id) => set((state) => ({ 
    items: state.items.filter(i => i.id !== id) 
  })),
  clearCart: () => set({ items: [] }),
}));

// Usage
function Cart() {
  const { items, removeItem } = useCartStore();
  
  return (
    <div>
      {items.map(item => (
        <div key={item.id}>
          {item.name}
          <button onClick={() => removeItem(item.id)}>Remove</button>
        </div>
      ))}
    </div>
  );
}
```

## Data Fetching Patterns

### Server Component Fetch
```typescript
async function getData() {
  const res = await fetch('https://api.example.com/data', {
    cache: 'force-cache', // Default caching
  });
  
  if (!res.ok) {
    throw new Error('Failed to fetch data');
  }
  
  return res.json();
}

export default async function Page() {
  const data = await getData();
  return <Display data={data} />;
}
```

### Client Component with SWR
```typescript
'use client';

import useSWR from 'swr';

const fetcher = (url: string) => fetch(url).then(r => r.json());

export function UserList() {
  const { data, error, isLoading } = useSWR('/api/users', fetcher, {
    refreshInterval: 5000, // Revalidate every 5s
    revalidateOnFocus: true,
  });
  
  if (isLoading) return <Spinner />;
  if (error) return <ErrorMessage error={error} />;
  
  return <div>{data.users.map(u => <UserCard key={u.id} user={u} />)}</div>;
}
```

### React Query (TanStack Query)
```typescript
'use client';

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

export function TodoList() {
  const queryClient = useQueryClient();
  
  const { data, isLoading } = useQuery({
    queryKey: ['todos'],
    queryFn: () => fetch('/api/todos').then(r => r.json()),
  });
  
  const mutation = useMutation({
    mutationFn: (newTodo: Todo) => 
      fetch('/api/todos', {
        method: 'POST',
        body: JSON.stringify(newTodo),
      }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    },
  });
  
  return (
    <div>
      {isLoading ? <Spinner /> : data.map(todo => <TodoItem key={todo.id} todo={todo} />)}
      <button onClick={() => mutation.mutate({ title: 'New Todo' })}>
        Add Todo
      </button>
    </div>
  );
}
```

## Form Handling

### React Hook Form with Zod
```typescript
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

const userSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  age: z.number().min(18, 'Must be at least 18 years old'),
});

type UserFormData = z.infer<typeof userSchema>;

export function UserForm() {
  const { register, handleSubmit, formState: { errors, isSubmitting } } = useForm<UserFormData>({
    resolver: zodResolver(userSchema),
  });
  
  const onSubmit = async (data: UserFormData) => {
    await fetch('/api/users', {
      method: 'POST',
      body: JSON.stringify(data),
    });
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label htmlFor="name">Name</label>
        <input id="name" {...register('name')} />
        {errors.name && <span>{errors.name.message}</span>}
      </div>
      
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" type="email" {...register('email')} />
        {errors.email && <span>{errors.email.message}</span>}
      </div>
      
      <div>
        <label htmlFor="age">Age</label>
        <input 
          id="age" 
          type="number" 
          {...register('age', { valueAsNumber: true })} 
        />
        {errors.age && <span>{errors.age.message}</span>}
      </div>
      
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Submitting...' : 'Submit'}
      </button>
    </form>
  );
}
```

## Error Handling

### Error Boundaries (Class Component)
```typescript
'use client';

import { Component, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div>
          <h2>Something went wrong</h2>
          <p>{this.state.error?.message}</p>
        </div>
      );
    }
    
    return this.props.children;
  }
}
```

### Try-Catch in Async Operations
```typescript
async function fetchUserData(id: string) {
  try {
    const response = await fetch(`/api/users/${id}`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    if (error instanceof Error) {
      console.error('Failed to fetch user:', error.message);
    }
    throw error; // Re-throw to handle at component level
  }
}
```

## Testing Best Practices

### Component Testing with React Testing Library
```typescript
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { UserProfile } from './UserProfile';

describe('UserProfile', () => {
  it('displays user name', async () => {
    render(<UserProfile userId="123" />);
    
    await waitFor(() => {
      expect(screen.getByText('John Doe')).toBeInTheDocument();
    });
  });
  
  it('handles button click', () => {
    const mockOnClick = jest.fn();
    render(<Button onClick={mockOnClick}>Click me</Button>);
    
    fireEvent.click(screen.getByRole('button'));
    
    expect(mockOnClick).toHaveBeenCalledTimes(1);
  });
  
  it('shows error state', () => {
    render(<UserProfile userId="invalid" />);
    
    expect(screen.getByText(/error/i)).toBeInTheDocument();
  });
});
```

### Hook Testing
```typescript
import { renderHook, act } from '@testing-library/react';
import { useCounter } from './useCounter';

describe('useCounter', () => {
  it('increments counter', () => {
    const { result } = renderHook(() => useCounter());
    
    act(() => {
      result.current.increment();
    });
    
    expect(result.current.count).toBe(1);
  });
});
```

## Styling with Tailwind CSS

### Utility-First Approach
```typescript
// ✅ Use Tailwind utilities
<button className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors">
  Click me
</button>

// ✅ Responsive design
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
  {items.map(item => <Card key={item.id} {...item} />)}
</div>

// ✅ Dark mode support
<div className="bg-white dark:bg-gray-800 text-black dark:text-white">
  Content
</div>
```

### Component Variants with CVA
```typescript
import { cva, type VariantProps } from 'class-variance-authority';

const buttonVariants = cva(
  'rounded font-semibold transition-colors',
  {
    variants: {
      variant: {
        primary: 'bg-blue-500 text-white hover:bg-blue-600',
        secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300',
        destructive: 'bg-red-500 text-white hover:bg-red-600',
      },
      size: {
        sm: 'px-3 py-1.5 text-sm',
        md: 'px-4 py-2 text-base',
        lg: 'px-6 py-3 text-lg',
      },
    },
    defaultVariants: {
      variant: 'primary',
      size: 'md',
    },
  }
);

interface ButtonProps extends VariantProps<typeof buttonVariants> {
  children: React.ReactNode;
}

export function Button({ variant, size, children }: ButtonProps) {
  return (
    <button className={buttonVariants({ variant, size })}>
      {children}
    </button>
  );
}
```

## Security Best Practices

### Input Sanitization
```typescript
import DOMPurify from 'isomorphic-dompurify';

function DisplayContent({ content }: { content: string }) {
  const sanitized = DOMPurify.sanitize(content);
  return <div dangerouslySetInnerHTML={{ __html: sanitized }} />;
}
```

### Environment Variables
```typescript
// ✅ Server-side only (no NEXT_PUBLIC_ prefix)
const apiKey = process.env.API_SECRET_KEY;

// ✅ Exposed to browser (NEXT_PUBLIC_ prefix required)
const publicKey = process.env.NEXT_PUBLIC_STRIPE_KEY;
```

### CSRF Protection
```typescript
// Server Action with token validation
'use server';

import { cookies } from 'next/headers';

export async function updateProfile(formData: FormData) {
  const token = cookies().get('csrf-token')?.value;
  
  if (!token || !validateToken(token)) {
    throw new Error('Invalid CSRF token');
  }
  
  // Process update
}
```

## Common Anti-Patterns to Avoid

❌ **Don't**: Use `useEffect` for derived state
```typescript
// Bad
const [items, setItems] = useState([]);
const [count, setCount] = useState(0);
useEffect(() => setCount(items.length), [items]);

// Good
const [items, setItems] = useState([]);
const count = items.length; // Derived during render
```

❌ **Don't**: Mutate state directly
```typescript
// Bad
items.push(newItem);
setItems(items);

// Good
setItems([...items, newItem]);
```

❌ **Don't**: Use index as key for dynamic lists
```typescript
// Bad
{items.map((item, index) => <Item key={index} {...item} />)}

// Good
{items.map(item => <Item key={item.id} {...item} />)}
```

❌ **Don't**: Forget cleanup in useEffect
```typescript
// Bad
useEffect(() => {
  const subscription = subscribe();
}, []);

// Good
useEffect(() => {
  const subscription = subscribe();
  return () => subscription.unsubscribe();
}, []);
```

❌ **Don't**: Overuse 'use client'
```typescript
// Bad - entire page is client-side
'use client';
export default function Page() { ... }

// Good - only interactive parts are client-side
export default function Page() {
  return (
    <>
      <ServerHeader />
      <ClientInteractive />
      <ServerFooter />
    </>
  );
}
```

## Code Review Checklist

- [ ] TypeScript types are precise (no `any`)
- [ ] Components follow single responsibility principle
- [ ] Server Components used by default, Client Components only when needed
- [ ] Proper error handling with try-catch and error boundaries
- [ ] Loading states implemented for async operations
- [ ] Form validation with Zod schemas
- [ ] Accessibility: semantic HTML, ARIA attributes, keyboard support
- [ ] Performance: memoization, code splitting, image optimization
- [ ] No console.log statements in production code
- [ ] Consistent naming conventions followed
- [ ] Props are properly typed with interfaces
- [ ] Event handlers are memoized when needed
- [ ] Effects have proper cleanup
- [ ] No direct state mutations
- [ ] Keys on list items are stable and unique
- [ ] Environment variables used correctly (NEXT_PUBLIC_ for client)
- [ ] Tailwind classes used instead of inline styles
- [ ] Responsive design implemented
- [ ] Dark mode support where applicable
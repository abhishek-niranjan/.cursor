---
description: Frontend architect that designs a responsive, interactive, and well-structured technical blueprint for the user interface.
alwaysApply: false
---
# Role & Responsibilities

The Frontend Architect designs a responsive, interactive, and well-structured technical blueprint for the user interface.

## Input Requirements

- ux-design-package from UX Designer
- backend-engineering-design-doc.md from Backend Engineer

## Output Deliverables

The Frontend Architect produces:

1. frontend-engineering-design-doc.md
   - Complete technical blueprint for the frontend
   - Implementation-ready specifications
   - Component architecture and data flow

# Process: Frontend Engineering Design

**Objective:** To produce a comprehensive technical blueprint that an implementation agent can follow to build the user interface with no ambiguity.

### 1. Author the `frontend-engineering-design-doc.md`
- Create a new Markdown file. This document will contain the following sections:

####    a. Overview
-   Write a 2-3 sentence summary of the frontend's purpose, referencing the wireframes and the user stories it implements.

####    b. Component Architecture & Flowchart
-   Plan your component hierarchy and visualize it with a **Mermaid.js flowchart**.

    ```mermaid
    graph TD
        subgraph DashboardPage
            A[ProjectList]
            B[CreateProjectButton]
        end
        A --> C(ProjectCard)
    ```

####    c. State Management Strategy
-   Define how the application will manage local, shared, and server cache state, including pseudocode for key interactions.

####    d. Core Data Structures
-   Define the primary client-side data structures for managing API data efficiently. This is crucial for a responsive UI.

    -   **Normalized Entity Cache:**
        -   **Structure:** Hash Map (or JavaScript Object).
        -   **Rationale:** Data from the API (e.g., a list of projects) often arrives as an array. For efficient lookups, updates, and deletions without iterating, we will transform this array into a normalized hash map where the key is the entity's ID.
        -   **Example Transformation:**
            -   *API Response (Array):* `[{ id: 'proj1', name: 'A' }, { id: 'proj2', name: 'B' }]`
            -   *Client-side Structure (Hash Map):*
                ```javascript
                {
                  'proj1': { id: 'proj1', name: 'A' },
                  'proj2': { id: 'proj2', name: 'B' }
                }
                ```
            -   This allows updating a project in O(1) time: `projects['proj1'].name = 'New Name'`.

    -   **Hierarchical Data (e.g., Nested Comments):**
        -   **Structure:** Tree.
        -   **Rationale:** To represent nested data, each comment object will have a `children` property containing an array of other comment objects. This structure directly maps to the recursive nature of rendering nested components.

####    e. API Service Layer Design
-   Define the functions and structure that will communicate with the backend.

    ```typescript
    // In src/services/api.ts
    class ApiService {
      async getProjects(): Promise<Project[]> { /* ... */ }
    }
    ```

####    f. Tech Stack Rationale
-   Briefly justify your technology choices to guide the implementation agent.
    -   **Framework:** e.g., "React with Vite."
    -   **State Management:** e.g., "SWR for server cache, which aligns with our normalized entity cache strategy."
    -   **Component Library:** e.g., "Chakra UI for accessibility."